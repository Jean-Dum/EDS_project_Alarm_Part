/* automatically generated by rust-bindgen */

use cty;

pub const XTAL_FREQ: u32 = 32000000;
pub const FREQ_STEP: f64 = 61.03515625;
pub const RX_BUFFER_SIZE: u32 = 256;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __uint32_t = cty::c_uint;
pub type size_t = cty::c_uint;
#[repr(C)]
pub struct LF_Gpio_t {
    pub Instance: *mut cty::c_void,
    pub port: *mut cty::c_void,
}
#[repr(C)]
pub struct LF_SPI_HandleTypeDef {
    pub Instance: *mut cty::c_void,
}
#[repr(C)]
pub struct LF_Spi_t {
    pub Spi: LF_SPI_HandleTypeDef,
    pub Nss: LF_Gpio_t,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AntPinsMode_t {
    AntModeTx = 0,
    AntModeRx = 1,
    AntModeSleep = 2,
    _AntModeMax = 4294967295,
}
pub const RadioModems_t_MODEM_FSK: RadioModems_t = 0;
pub const RadioModems_t_MODEM_LORA: RadioModems_t = 1;
#[doc = " Radio driver supported modems"]
pub type RadioModems_t = u32;
#[doc = "!< The radio is idle"]
pub const RadioState_t_RF_IDLE: RadioState_t = 0;
#[doc = "!< The radio is in reception state"]
pub const RadioState_t_RF_RX_RUNNING: RadioState_t = 1;
#[doc = "!< The radio is in transmission state"]
pub const RadioState_t_RF_TX_RUNNING: RadioState_t = 2;
#[doc = "!< The radio is doing channel activity detection"]
pub const RadioState_t_RF_CAD: RadioState_t = 3;
#[doc = " Radio driver internal state machine states definition"]
pub type RadioState_t = u32;
#[doc = " \\brief Radio driver callback functions"]
#[repr(C)]
pub struct RadioEvents_t {
    #[doc = " \\brief  Tx Done callback prototype."]
    pub TxDone: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " \\brief  Tx Timeout callback prototype."]
    pub TxTimeout: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " \\brief Rx Done callback prototype."]
    #[doc = ""]
    #[doc = " \\param [IN] payload Received buffer pointer"]
    #[doc = " \\param [IN] size    Received buffer size"]
    #[doc = " \\param [IN] rssi    RSSI value computed while receiving the frame [dBm]"]
    #[doc = " \\param [IN] snr     SNR value computed while receiving the frame [dB]"]
    #[doc = "                     FSK : N/A ( set to 0 )"]
    #[doc = "                     LoRa: SNR value in dB"]
    pub RxDone: ::core::option::Option<
        unsafe extern "C" fn(payload: *mut u8, size: u16, rssi: i16, snr: i8),
    >,
    #[doc = " \\brief  Rx Timeout callback prototype."]
    pub RxTimeout: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " \\brief Rx Error callback prototype."]
    pub RxError: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " \\brief  FHSS Change Channel callback prototype."]
    #[doc = ""]
    #[doc = " \\param [IN] currentChannel   Index number of the current channel"]
    pub FhssChangeChannel: ::core::option::Option<unsafe extern "C" fn(currentChannel: u8)>,
    #[doc = " \\brief CAD Done callback prototype."]
    #[doc = ""]
    #[doc = " \\param [IN] channelDetected    Channel Activity detected during the CAD"]
    pub CadDone: ::core::option::Option<unsafe extern "C" fn(channelActivityDetected: bool)>,
}
#[doc = " \\brief Radio driver definition"]
#[repr(C)]
pub struct Radio_s {
    #[doc = " \\brief Initializes the radio"]
    #[doc = ""]
    #[doc = " \\param [IN] events Structure containing the driver callback functions"]
    pub Init: ::core::option::Option<unsafe extern "C" fn(events: *mut RadioEvents_t)>,
    #[doc = " Return current radio status"]
    #[doc = ""]
    #[doc = " \\param status Radio status.[RF_IDLE, RF_RX_RUNNING, RF_TX_RUNNING]"]
    pub GetStatus: ::core::option::Option<unsafe extern "C" fn() -> RadioState_t>,
    #[doc = " \\brief Configures the radio with the given modem"]
    #[doc = ""]
    #[doc = " \\param [IN] modem Modem to be used [0: FSK, 1: LoRa]"]
    pub SetModem: ::core::option::Option<unsafe extern "C" fn(modem: RadioModems_t)>,
    #[doc = " \\brief Sets the channel frequency"]
    #[doc = ""]
    #[doc = " \\param [IN] freq         Channel RF frequency"]
    pub SetChannel: ::core::option::Option<unsafe extern "C" fn(freq: u32)>,
    #[doc = " \\brief Checks if the channel is free for the given time"]
    #[doc = ""]
    #[doc = " \\param [IN] modem      Radio modem to be used [0: FSK, 1: LoRa]"]
    #[doc = " \\param [IN] freq       Channel RF frequency"]
    #[doc = " \\param [IN] rssiThresh RSSI threshold"]
    #[doc = " \\param [IN] maxCarrierSenseTime Max time while the RSSI is measured"]
    #[doc = ""]
    #[doc = " \\retval isFree         [true: Channel is free, false: Channel is not free]"]
    pub IsChannelFree: ::core::option::Option<
        unsafe extern "C" fn(
            modem: RadioModems_t,
            freq: u32,
            rssiThresh: i16,
            maxCarrierSenseTime: u32,
        ) -> bool,
    >,
    #[doc = " \\brief Generates a 32 bits random value based on the RSSI readings"]
    #[doc = ""]
    #[doc = " \\remark This function sets the radio in LoRa modem mode and disables"]
    #[doc = "         all interrupts."]
    #[doc = "         After calling this function either Radio.SetRxConfig or"]
    #[doc = "         Radio.SetTxConfig functions must be called."]
    #[doc = ""]
    #[doc = " \\retval randomValue    32 bits random value"]
    pub Random: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    #[doc = " \\brief Sets the reception parameters"]
    #[doc = ""]
    #[doc = " \\param [IN] modem        Radio modem to be used [0: FSK, 1: LoRa]"]
    #[doc = " \\param [IN] bandwidth    Sets the bandwidth"]
    #[doc = "                          FSK : >= 2600 and <= 250000 Hz"]
    #[doc = "                          LoRa: [0: 125 kHz, 1: 250 kHz,"]
    #[doc = "                                 2: 500 kHz, 3: Reserved]"]
    #[doc = " \\param [IN] datarate     Sets the Datarate"]
    #[doc = "                          FSK : 600..300000 bits/s"]
    #[doc = "                          LoRa: [6: 64, 7: 128, 8: 256, 9: 512,"]
    #[doc = "                                10: 1024, 11: 2048, 12: 4096  chips]"]
    #[doc = " \\param [IN] coderate     Sets the coding rate (LoRa only)"]
    #[doc = "                          FSK : N/A ( set to 0 )"]
    #[doc = "                          LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8]"]
    #[doc = " \\param [IN] bandwidthAfc Sets the AFC Bandwidth (FSK only)"]
    #[doc = "                          FSK : >= 2600 and <= 250000 Hz"]
    #[doc = "                          LoRa: N/A ( set to 0 )"]
    #[doc = " \\param [IN] preambleLen  Sets the Preamble length"]
    #[doc = "                          FSK : Number of bytes"]
    #[doc = "                          LoRa: Length in symbols (the hardware adds 4 more symbols)"]
    #[doc = " \\param [IN] symbTimeout  Sets the RxSingle timeout value"]
    #[doc = "                          FSK : timeout in number of bytes"]
    #[doc = "                          LoRa: timeout in symbols"]
    #[doc = " \\param [IN] fixLen       Fixed length packets [0: variable, 1: fixed]"]
    #[doc = " \\param [IN] payloadLen   Sets payload length when fixed length is used"]
    #[doc = " \\param [IN] crcOn        Enables/Disables the CRC [0: OFF, 1: ON]"]
    #[doc = " \\param [IN] freqHopOn    Enables disables the intra-packet frequency hopping"]
    #[doc = "                          FSK : N/A ( set to 0 )"]
    #[doc = "                          LoRa: [0: OFF, 1: ON]"]
    #[doc = " \\param [IN] hopPeriod    Number of symbols between each hop"]
    #[doc = "                          FSK : N/A ( set to 0 )"]
    #[doc = "                          LoRa: Number of symbols"]
    #[doc = " \\param [IN] iqInverted   Inverts IQ signals (LoRa only)"]
    #[doc = "                          FSK : N/A ( set to 0 )"]
    #[doc = "                          LoRa: [0: not inverted, 1: inverted]"]
    #[doc = " \\param [IN] rxContinuous Sets the reception in continuous mode"]
    #[doc = "                          [false: single mode, true: continuous mode]"]
    pub SetRxConfig: ::core::option::Option<
        unsafe extern "C" fn(
            modem: RadioModems_t,
            bandwidth: u32,
            datarate: u32,
            coderate: u8,
            bandwidthAfc: u32,
            preambleLen: u16,
            symbTimeout: u16,
            fixLen: bool,
            payloadLen: u8,
            crcOn: bool,
            freqHopOn: bool,
            hopPeriod: u8,
            iqInverted: bool,
            rxContinuous: bool,
        ),
    >,
    #[doc = " \\brief Sets the transmission parameters"]
    #[doc = ""]
    #[doc = " \\param [IN] modem        Radio modem to be used [0: FSK, 1: LoRa]"]
    #[doc = " \\param [IN] power        Sets the output power [dBm]"]
    #[doc = " \\param [IN] fdev         Sets the frequency deviation (FSK only)"]
    #[doc = "                          FSK : [Hz]"]
    #[doc = "                          LoRa: 0"]
    #[doc = " \\param [IN] bandwidth    Sets the bandwidth (LoRa only)"]
    #[doc = "                          FSK : 0"]
    #[doc = "                          LoRa: [0: 125 kHz, 1: 250 kHz,"]
    #[doc = "                                 2: 500 kHz, 3: Reserved]"]
    #[doc = " \\param [IN] datarate     Sets the Datarate"]
    #[doc = "                          FSK : 600..300000 bits/s"]
    #[doc = "                          LoRa: [6: 64, 7: 128, 8: 256, 9: 512,"]
    #[doc = "                                10: 1024, 11: 2048, 12: 4096  chips]"]
    #[doc = " \\param [IN] coderate     Sets the coding rate (LoRa only)"]
    #[doc = "                          FSK : N/A ( set to 0 )"]
    #[doc = "                          LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8]"]
    #[doc = " \\param [IN] preambleLen  Sets the preamble length"]
    #[doc = "                          FSK : Number of bytes"]
    #[doc = "                          LoRa: Length in symbols (the hardware adds 4 more symbols)"]
    #[doc = " \\param [IN] fixLen       Fixed length packets [0: variable, 1: fixed]"]
    #[doc = " \\param [IN] crcOn        Enables disables the CRC [0: OFF, 1: ON]"]
    #[doc = " \\param [IN] freqHopOn    Enables disables the intra-packet frequency hopping"]
    #[doc = "                          FSK : N/A ( set to 0 )"]
    #[doc = "                          LoRa: [0: OFF, 1: ON]"]
    #[doc = " \\param [IN] hopPeriod    Number of symbols between each hop"]
    #[doc = "                          FSK : N/A ( set to 0 )"]
    #[doc = "                          LoRa: Number of symbols"]
    #[doc = " \\param [IN] iqInverted   Inverts IQ signals (LoRa only)"]
    #[doc = "                          FSK : N/A ( set to 0 )"]
    #[doc = "                          LoRa: [0: not inverted, 1: inverted]"]
    #[doc = " \\param [IN] timeout      Transmission timeout [ms]"]
    pub SetTxConfig: ::core::option::Option<
        unsafe extern "C" fn(
            modem: RadioModems_t,
            power: i8,
            fdev: u32,
            bandwidth: u32,
            datarate: u32,
            coderate: u8,
            preambleLen: u16,
            fixLen: bool,
            crcOn: bool,
            freqHopOn: bool,
            hopPeriod: u8,
            iqInverted: bool,
            timeout: u32,
        ),
    >,
    #[doc = " \\brief Checks if the given RF frequency is supported by the hardware"]
    #[doc = ""]
    #[doc = " \\param [IN] frequency RF frequency to be checked"]
    #[doc = " \\retval isSupported [true: supported, false: unsupported]"]
    pub CheckRfFrequency: ::core::option::Option<unsafe extern "C" fn(frequency: u32) -> bool>,
    #[doc = " \\brief Computes the packet time on air in ms for the given payload"]
    #[doc = ""]
    #[doc = " \\Remark Can only be called once SetRxConfig or SetTxConfig have been called"]
    #[doc = ""]
    #[doc = " \\param [IN] modem      Radio modem to be used [0: FSK, 1: LoRa]"]
    #[doc = " \\param [IN] pktLen     Packet payload length"]
    #[doc = ""]
    #[doc = " \\retval airTime        Computed airTime (ms) for the given packet payload length"]
    pub TimeOnAir:
        ::core::option::Option<unsafe extern "C" fn(modem: RadioModems_t, pktLen: u8) -> u32>,
    #[doc = " \\brief Sends the buffer of size. Prepares the packet to be sent and sets"]
    #[doc = "        the radio in transmission"]
    #[doc = ""]
    #[doc = " \\param [IN]: buffer     Buffer pointer"]
    #[doc = " \\param [IN]: size       Buffer size"]
    pub Send: ::core::option::Option<unsafe extern "C" fn(buffer: *mut u8, size: u8)>,
    #[doc = " \\brief Sets the radio in sleep mode"]
    pub Sleep: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " \\brief Sets the radio in standby mode"]
    pub Standby: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " \\brief Sets the radio in reception mode for the given time"]
    #[doc = " \\param [IN] timeout Reception timeout [ms]"]
    #[doc = "                     [0: continuous, others timeout]"]
    pub Rx: ::core::option::Option<unsafe extern "C" fn(timeout: u32)>,
    #[doc = " \\brief Start a Channel Activity Detection"]
    pub StartCad: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " \\brief Sets the radio in continuous wave transmission mode"]
    #[doc = ""]
    #[doc = " \\param [IN]: freq       Channel RF frequency"]
    #[doc = " \\param [IN]: power      Sets the output power [dBm]"]
    #[doc = " \\param [IN]: time       Transmission mode timeout [s]"]
    pub SetTxContinuousWave:
        ::core::option::Option<unsafe extern "C" fn(freq: u32, power: i8, time: u16)>,
    #[doc = " \\brief Reads the current RSSI value"]
    #[doc = ""]
    #[doc = " \\retval rssiValue Current RSSI value in [dBm]"]
    pub Rssi: ::core::option::Option<unsafe extern "C" fn(modem: RadioModems_t) -> i16>,
    #[doc = " \\brief Writes the radio register at the specified address"]
    #[doc = ""]
    #[doc = " \\param [IN]: addr Register address"]
    #[doc = " \\param [IN]: data New register value"]
    pub Write: ::core::option::Option<unsafe extern "C" fn(addr: u16, data: u8)>,
    #[doc = " \\brief Reads the radio register at the specified address"]
    #[doc = ""]
    #[doc = " \\param [IN]: addr Register address"]
    #[doc = " \\retval data Register value"]
    pub Read: ::core::option::Option<unsafe extern "C" fn(addr: u16) -> u8>,
    #[doc = " \\brief Writes multiple radio registers starting at address"]
    #[doc = ""]
    #[doc = " \\param [IN] addr   First Radio register address"]
    #[doc = " \\param [IN] buffer Buffer containing the new register's values"]
    #[doc = " \\param [IN] size   Number of registers to be written"]
    pub WriteBuffer:
        ::core::option::Option<unsafe extern "C" fn(addr: u16, buffer: *mut u8, size: u8)>,
    #[doc = " \\brief Reads multiple radio registers starting at address"]
    #[doc = ""]
    #[doc = " \\param [IN] addr First Radio register address"]
    #[doc = " \\param [OUT] buffer Buffer where to copy the registers data"]
    #[doc = " \\param [IN] size Number of registers to be read"]
    pub ReadBuffer:
        ::core::option::Option<unsafe extern "C" fn(addr: u16, buffer: *mut u8, size: u8)>,
    #[doc = " \\brief Sets the maximum payload length."]
    #[doc = ""]
    #[doc = " \\param [IN] modem      Radio modem to be used [0: FSK, 1: LoRa]"]
    #[doc = " \\param [IN] max        Maximum payload length in bytes"]
    pub SetMaxPayloadLength:
        ::core::option::Option<unsafe extern "C" fn(modem: RadioModems_t, max: u8)>,
    #[doc = " \\brief Sets the network to public or private. Updates the sync byte."]
    #[doc = ""]
    #[doc = " \\remark Applies to LoRa modem only"]
    #[doc = ""]
    #[doc = " \\param [IN] enable if true, it enables a public network"]
    pub SetPublicNetwork: ::core::option::Option<unsafe extern "C" fn(enable: bool)>,
    #[doc = " \\brief Gets the time required for the board plus radio to get out of sleep.[ms]"]
    #[doc = ""]
    #[doc = " \\retval time Radio plus board wakeup time in ms."]
    pub GetWakeupTime: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    #[doc = " \\brief Process radio irq"]
    pub IrqProcess: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " \\brief Sets the radio in reception mode with Max LNA gain for the given time"]
    #[doc = ""]
    #[doc = " \\remark Available on SX126x radios only."]
    #[doc = ""]
    #[doc = " \\param [IN] timeout Reception timeout [ms]"]
    #[doc = "                     [0: continuous, others timeout]"]
    pub RxBoosted: ::core::option::Option<unsafe extern "C" fn(timeout: u32)>,
    #[doc = " \\brief Sets the Rx duty cycle management parameters"]
    #[doc = ""]
    #[doc = " \\remark Available on SX126x radios only."]
    #[doc = ""]
    #[doc = " \\param [in]  rxTime        Structure describing reception timeout value"]
    #[doc = " \\param [in]  sleepTime     Structure describing sleep timeout value"]
    pub SetRxDutyCycle: ::core::option::Option<unsafe extern "C" fn(rxTime: u32, sleepTime: u32)>,
    #[doc = " \\brief Enables Tcxo"]
    #[doc = ""]
    #[doc = " \\remark Implemented for SX1276 only"]
    #[doc = ""]
    #[doc = " \\param [in]  bool        To enable or disable Tcxo"]
    pub EnableTcxo: ::core::option::Option<unsafe extern "C" fn()>,
}
pub type Radio_t = Radio_s;
#[repr(C)]
pub struct BoardBindings_t {
    pub spi_in_out:
        ::core::option::Option<unsafe extern "C" fn(obj: *mut LF_Spi_t, outData: u8) -> u8>,
    pub spi_nss: ::core::option::Option<unsafe extern "C" fn(sel: bool)>,
    pub reset: ::core::option::Option<unsafe extern "C" fn(enable: bool)>,
    pub delay_ms: ::core::option::Option<unsafe extern "C" fn(arg1: u32)>,
    pub get_random_bits: ::core::option::Option<unsafe extern "C" fn(arg1: u8) -> u32>,
    pub set_board_tcxo: ::core::option::Option<unsafe extern "C" fn(enable: bool) -> u8>,
    pub set_antenna_pins:
        ::core::option::Option<unsafe extern "C" fn(mode: AntPinsMode_t, power: u8)>,
}
#[repr(C)]
pub struct RfConfig_t {
    pub oui: u32,
    pub device_id: u16,
}
#[repr(C)]
pub struct LongFi_t {
    pub radio: *mut Radio_t,
    pub bindings: *mut BoardBindings_t,
    pub config: RfConfig_t,
}
extern "C" {
    pub fn longfi_new_handle(
        bindings: *mut BoardBindings_t,
        radio: *mut Radio_t,
        config: RfConfig_t,
    ) -> LongFi_t;
}
extern "C" {
    pub fn longfi_init(handle: *mut LongFi_t);
}
extern "C" {
    pub fn longfi_enable_tcxo(handle: *mut LongFi_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ClientEvent_t {
    ClientEvent_None = 0,
    ClientEvent_TxDone = 1,
    ClientEvent_Rx = 2,
}
extern "C" {
    pub fn longfi_set_buf(handle: *mut LongFi_t, buffer: *mut u8, buffer_len: size_t);
}
extern "C" {
    pub fn longfi_rx(handle: *mut LongFi_t);
}
extern "C" {
    pub fn longfi_send(handle: *mut LongFi_t, data: *const u8, len: size_t);
}
#[repr(C)]
pub struct RxPacket_t {
    pub buf: *mut u8,
    pub len: size_t,
    pub rssi: i16,
    pub snr: i8,
}
extern "C" {
    pub fn longfi_get_rx() -> RxPacket_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RfEvent_t {
    DIO0 = 0,
    DIO1 = 1,
    DIO2 = 2,
    DIO3 = 3,
    DIO4 = 4,
    DIO5 = 5,
    Timer1 = 6,
    Timer2 = 7,
    Timer3 = 8,
}
extern "C" {
    pub fn longfi_handle_event(handle: *mut LongFi_t, rf_event: RfEvent_t) -> ClientEvent_t;
}
extern "C" {
    pub fn longfi_rf_test(handle: *mut LongFi_t);
}
extern "C" {
    pub fn longfi_get_random(handle: *mut LongFi_t) -> u32;
}
extern "C" {
    pub fn SX1276RadioNew() -> Radio_t;
}
